From 2826483b98cd297512b48d54b2557f9d00cac9a6 Mon Sep 17 00:00:00 2001
From: Guillem Jover <guillem@hadrons.org>
Date: Tue, 27 Aug 2024 01:25:40 +0200
Subject: [PATCH 1/2] Fix typos
Forwarded: https://github.com/axboe/liburing/pull/1212

Warned-by: codespell
Signed-off-by: Guillem Jover <guillem@hadrons.org>
---
 examples/proxy.c                | 6 +++---
 man/io_uring_prep_recv.3        | 2 +-
 man/io_uring_prep_send.3        | 2 +-
 src/include/liburing/io_uring.h | 2 +-
 test/ignore-single-mmap.c       | 2 +-
 5 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/examples/proxy.c b/examples/proxy.c
index 67df81e..d50c9dc 100644
--- a/examples/proxy.c
+++ b/examples/proxy.c
@@ -132,7 +132,7 @@ struct io_msg {
 
 /*
  * Per socket stats per connection. For bi-directional, we'll have both
- * sends and receives on each socket, this helps track them seperately.
+ * sends and receives on each socket, this helps track them separately.
  * For sink or one directional, each of the two stats will be only sends
  * or receives, not both.
  */
@@ -298,7 +298,7 @@ static int default_error(struct error_handler *err,
 }
 
 /*
- * Move error handling out of the normal handling path, cleanly seperating
+ * Move error handling out of the normal handling path, cleanly separating
  * them. If an opcode doesn't need any error handling, set it to NULL. If
  * it wants to stop the connection at that point and not do anything else,
  * then the default handler can be used. Only receive has proper error
@@ -1684,7 +1684,7 @@ static int handle_shutdown(struct io_uring *ring, struct io_uring_cqe *cqe)
 	struct io_uring_sqe *sqe;
 	int fd = cqe_to_fd(cqe);
 
-	fprintf(stderr, "Got shutdown notication on fd %d\n", fd);
+	fprintf(stderr, "Got shutdown notification on fd %d\n", fd);
 
 	if (!cqe->res)
 		fprintf(stderr, "Unexpected success shutdown CQE\n");
diff --git a/man/io_uring_prep_recv.3 b/man/io_uring_prep_recv.3
index 36336ed..0fd74b2 100644
--- a/man/io_uring_prep_recv.3
+++ b/man/io_uring_prep_recv.3
@@ -97,7 +97,7 @@ field indicates the first buffer in the receive operation. The application must
 iterate from the indicated initial buffer ID and until all
 .I res
 bytes have been seen to know which is the last buffer in the receive operation.
-The buffer IDs consumed will be contigious from the starting ID, in the order
+The buffer IDs consumed will be contiguous from the starting ID, in the order
 in which they were added to the buffer ring used. Receiving in bundles can
 improve performance when more than one chunk of data is available to receive,
 by eliminating redundant round trips through the networking stack. Receive
diff --git a/man/io_uring_prep_send.3 b/man/io_uring_prep_send.3
index f1d9b15..e61ea43 100644
--- a/man/io_uring_prep_send.3
+++ b/man/io_uring_prep_send.3
@@ -111,7 +111,7 @@ to limit the transfer size. A single CQE is posted for the send, with the result
 being how many bytes were sent, on success. When used with provided buffers,
 send or send bundle will contain the starting buffer group ID in the CQE
 .I flags
-field. The number of bytes sent starts from there, and will be in contigious
+field. The number of bytes sent starts from there, and will be in contiguous
 buffer IDs after that. Send bundle, and send with provided buffers in general,
 are available since kernel 6.10, and can be further identified by checking for
 the
diff --git a/src/include/liburing/io_uring.h b/src/include/liburing/io_uring.h
index 01c36a8..c857bb7 100644
--- a/src/include/liburing/io_uring.h
+++ b/src/include/liburing/io_uring.h
@@ -356,7 +356,7 @@ enum io_uring_op {
  *				will be the number of buffers send, with the
  *				starting buffer ID in cqe->flags as per usual
  *				for provided buffer usage. The buffers will be
- *				contigious from the starting buffer ID.
+ *				contiguous from the starting buffer ID.
  */
 #define IORING_RECVSEND_POLL_FIRST	(1U << 0)
 #define IORING_RECV_MULTISHOT		(1U << 1)
diff --git a/test/ignore-single-mmap.c b/test/ignore-single-mmap.c
index c237d83..455d90e 100644
--- a/test/ignore-single-mmap.c
+++ b/test/ignore-single-mmap.c
@@ -2,7 +2,7 @@
 /*
  * 6.10-rc merge window had a bug where the rewritten mmap support caused
  * rings allocated with > 1 page, but asking for smaller mappings, would
- * cause -EFAULT to be returned rather than a succesful map. This hit
+ * cause -EFAULT to be returned rather than a successful map. This hit
  * applications either using an ancient liburing with IORING_FEAT_SINGLE_MMAP
  * support, or application just ignoring that feature flag and still doing
  * 3 mmap operations to map the ring.
-- 
2.45.2

